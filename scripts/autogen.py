import re
import argparse
import logging
import textwrap
import system_calls
from pathlib import Path
from dataclasses import dataclass, fields
from typing import List, Dict, Any, Callable, Set, Optional, Tuple, Type

# Import definition objects
from syscall_definitions import SYSCALLS, Syscall, Nrs, ScArg
from type_system import TypeSystem

@dataclass
class GeneratorContext:
    ts: TypeSystem
    archs: List[str]
    syscalls: Dict[str, Syscall]

    @classmethod
    def create(cls) -> 'GeneratorContext':
        logging.info("Creating context...")
        # Load Type System
        ts = TypeSystem.load(Path('templates'))
        archs = [f.name for f in fields(Nrs)]
        return cls(ts, archs, SYSCALLS)


# --- Base Generator ---
class StubGenerator:
    def __init__(self, spath: Path, context: GeneratorContext):
        self.spath = spath
        self.spath.mkdir(parents=True, exist_ok=True)
        self.ctx = context

    @property
    def ts(self) -> TypeSystem:
        return self.ctx.ts

    @property
    def archs(self) -> List[str]:
        return self.ctx.archs
    
    @property
    def syscalls(self) -> Dict[str, Syscall]:
        return self.ctx.syscalls

    def generate(self):
        raise NotImplementedError

    def write_file(self, filename: str, content: str):
        """Writes content to file at self.spath / filename."""
        with open(self.spath / filename, 'w') as f:
            f.write(content)

    def gen_and_write(self, stub_fn: Callable, filename: str, include_unimplemented_calls: bool = False, prelude: str = "", postlude: str = ""):
        # Call stubs for each syscall
        buf = [stub_fn(sc) for sc in self.syscalls.values() if include_unimplemented_calls or sc.implemented]
        # Construct content: prelude + joined stubs + postlude
        content_parts = []
        if prelude: content_parts.append(prelude)
        content_parts.append('\n'.join(buf))
        if postlude: content_parts.append(postlude)
        self.write_file(filename, '\n'.join(content_parts))


# --- Specific Generators ---

class LibcGenerator(StubGenerator):
    def generate(self):
        self._gen_c_stubs()
        self._gen_rust_stubs()

    def _ptr_anonymize(self, args: List[ScArg]) -> List[str]:
        """Anonymize pointer argument types to void* for non-basic pointer types."""
        def f(arg: ScArg):
            (indir, base) = arg.ptr_split(max=1)
            return 'void*' if indir > 0 and not base.is_basic_type(self.ts) else arg
        
        return [f(arg) for arg in args]

    def rustify_args(self, sc: Syscall) -> List[str]:
        """Convert argument types to Rust compatible types"""
        def f(arg: ScArg):
            if arg.is_ptr():
                return 'i32'
            while arg not in self.ts.wit_primitive_set:
                try:
                    arg = self.ts.combined_types[arg]
                except KeyError as e:
                    raise RuntimeError(f"Type '{arg}' not found in combined types (used in syscall '{sc.name}')") from e

            return arg if not arg.startswith('s') else 'i' + arg[1:]
        
        return [f(x) for x in sc.args_reduce(self.ts)]


    def _gen_c_stubs(self):
        def def_stub(sc: Syscall):
            arglist = ','.join(self._ptr_anonymize(sc.args_reduce(self.ts)))
            s = f"WALI_SYSCALL_DEF ({sc.name}, {arglist});"
            for alias in sc.aliases:
                s += f"\n#define __syscall_SYS_{alias} __syscall_SYS_{sc.name}"
            return s

        def case_stub(sc: Syscall):
            anon_args = self._ptr_anonymize(sc.args_reduce(self.ts))
            arglist = ','.join([f"({typ})a{i+1}" for i, typ in enumerate(anon_args)])
            return f"\t\tCASE_SYSCALL ({sc.name}, {arglist});"

        self.gen_and_write(def_stub, 'defs.out', True)
        self.gen_and_write(case_stub, 'case.out')

    def _gen_rust_stubs(self):
        rpath = self.spath / 'rust'
        rpath.mkdir(parents=True, exist_ok=True)


        def rust_def_stub(sc: Syscall):
            rust_args = self.rustify_args(sc)
            argtys = ', '.join([f"a{i+1}: {typ}" for i, typ in enumerate(rust_args)])
            
            code = textwrap.dedent(f"""\
                /* {sc.nr} */
                #[link_name = "SYS_{sc.name}"]
                pub fn __syscall_SYS_{sc.name}({argtys}) -> ::c_long;""")
            return textwrap.indent(code, '\t')

        def rust_match_stub(sc: Syscall):
            if sc.implemented:
                call_args = ', '.join([f"a{x}" for x, _ in enumerate(sc.args_reduce(self.ts))])
                code = f"super::SYS_{sc.name} => syscall_match_arm!(SYS_{sc.name}, args, {call_args}),"
            else:
                code = f"super::SYS_{sc.name} => unimplemented!(\"WALI syscall '{sc.name}' ({sc.nr}) unimplemented!\"),"
            return textwrap.indent(code, '\t\t')

        def_prelude = textwrap.dedent("""\
            // --- Autogenerated from WALI/scripts/autogen.py ---
            #[link(wasm_import_module = "wali")]
            extern "C" {""")
        def_postlude = "\n}"
        
        # We need a slightly custom writer for rust subdirectory or override gen_and_write
        # But base class gen_and_write writes to self.spath / filename.
        # We can pass 'rust/defs.out' as filename.
        self.gen_and_write(rust_def_stub, 'rust/defs.out', False, def_prelude, def_postlude)

        match_prelude = textwrap.dedent("""\
            #[no_mangle]
            pub unsafe extern "C" fn syscall(num: ::c_long, mut args: ...) -> ::c_long {
                use core::unimplemented;
                match num {""")
        match_postlude = textwrap.dedent("""\
                _ => unimplemented!("WALI syscall number {} out-of-scope!", num),
            }
        }""")
        self.gen_and_write(rust_match_stub, 'rust/match.out', True, match_prelude, match_postlude)


class WamrGenerator(StubGenerator):
    def generate(self):
        def declr_stub(sc: Syscall):
            arglist = ''.join([f", long a{i+1}" for i, _ in enumerate(sc.args_reduce(self.ts))])
            return f"long wali_syscall_{sc.name} (wasm_exec_env_t exec_env{arglist});"

        def impl_stub(sc: Syscall):
            args_red = sc.args_reduce(self.ts)
            arglist_def = ''.join([f", long a{i+1}" for i, _ in enumerate(args_red)])
            
            # Construct return call args
            ret_args = []
            for i, argty in enumerate(args_red):
                if argty.endswith('*'):
                    ret_args.append(f", MADDR(a{i+1})")
                else:
                    ret_args.append(f", a{i+1}")
            ret_arglist = ''.join(ret_args)
            
            return textwrap.dedent(f"""\
                // {sc.nr} TODO
                long wali_syscall_{sc.name} (wasm_exec_env_t exec_env{arglist_def}) {{
                    SC({sc.nr}, {sc.name});
                    ERRSC({sc.name});
                    RETURN(__syscall{len(args_red)}(SYS_{sc.name}{ret_arglist}));
                }}
                """)

        def symbols_stub(sc: Syscall):
            def gen_native_args(args_list):
                params = ''.join(["I" if x.endswith("long long") or x.endswith("long") else "i" for x in args_list])
                return f"\"({params})I\""

            return "\tNSYMBOL ( {: >20}, {: >30}, {: >12} ),".format(
                "SYS_" + sc.name,
                "wali_syscall_" + sc.name,
                gen_native_args(sc.args_reduce(self.ts))
            )

        self.gen_and_write(declr_stub, 'declr.out')
        self.gen_and_write(impl_stub, 'impl.out')
        self.gen_and_write(symbols_stub, 'symbols.out')


class WitGenerator(StubGenerator):
    def generate(self):
        buf = []
        uniq_ptr_types = set()

        def transform_ptr_arg(arg):
            arg_no_ptr = arg.rstrip('*')
            ptr_indirection = len(arg) - len(arg_no_ptr)
            return ("ptr-" * ptr_indirection) + arg_no_ptr

        for sc in self.syscalls.values():
            args = [x.strip().replace(' ', '-').replace('_', '-') for x in sc.args]
            args = [transform_ptr_arg(x) for x in args]
            
            up_types = set([x for x in args if x.startswith('ptr-')])
            uniq_ptr_types.update(up_types)

            if sc.num_args:
                l1 = f"\t// [{sc.nr}] {sc.name}({', '.join(sc.args)})"
                wit_args = ', '.join([
                    f"a{i+1}: {self.ts.basic_types[arg] if arg in self.ts.basic_types else arg}" 
                    for i, arg in enumerate(args)
                ])
                l2 = f"\tSYS-{sc.name.replace('_', '-')}: func({wit_args}) -> syscall-result;"
                buf.append(l1 + '\n' + l2)

        buf = list(filter(bool, buf))
        
        self._generate_wit_file(buf, uniq_ptr_types)

    def _generate_wit_file(self, buf, uniq_ptr_types):
        rep = lambda p: p.replace('_', '-').replace(' ', '-')
        comp_types = {'syscall-result': 's64'}
        for k, v in (self.ts.basic_types | self.ts.complex_types).items():
             val = rep(v) if not v.startswith('Array') else v.replace('_', '-')
             comp_types[rep(k)] = val

        type_if = ["interface types {"] + \
                  [f"\ttype {k} = {v};" for k, v in comp_types.items()] + \
                  ["}"]

        # Process Records
        # Assuming templates dir relative to CWD
        with open('templates/records.wit.template') as f:
            record_content = f.read()

        record_types = set(re.findall(r'record (\S+)', record_content))
        sc_ptr_types = set()
        
        for x in uniq_ptr_types:
            x_no_ptr = x
            while x_no_ptr.startswith("ptr-"):
                x_no_ptr = x_no_ptr.replace("ptr-", "", 1)
            
            # Helper to check validity
            is_skippable = (x_no_ptr in self.ts.basic_types or 
                            x_no_ptr in comp_types or 
                            x_no_ptr in ['void', 'char'])
            if not is_skippable:
                sc_ptr_types.add(x_no_ptr)

        missing_types = sc_ptr_types.difference(record_types)
        if missing_types:
            logging.warning(f"Missing Records for Complex Types: {missing_types}")
        else:
            logging.info("Successfully bound all records")
        
        sc_prelude = (
            ["interface syscalls {"] +
            [f"\tuse types.{{{', '.join(comp_types)}}};"] +
            ["\t/// Readable pointer types"] +
            [f"\ttype {x} = ptr;" for x in sorted(uniq_ptr_types)] +
            ["", "\t/// Record types"] +
            ["\t" + '\n\t'.join(record_content.split('\n'))] +
            [""]
        )

        sc_if = sc_prelude + ["\t/// Syscall methods"] + buf + ["}"]

        try:
            with open('templates/wali.wit.template', 'r') as f:
                template = f.read()
        except FileNotFoundError:
             template = "[[TYPES_STUB]]\n[[SYSCALLS_STUB]]"

        fill_temp = template.replace(
            '[[TYPES_STUB]]', '\n'.join(type_if)
        ).replace(
            '[[SYSCALLS_STUB]]', '\n'.join(sc_if)
        )

        def matchrep(matchobj):
            num_elem, ty = matchobj.groups()
            return "tuple<{}>".format(','.join([ty] * int(num_elem)))

        # TEMPORARY: No fixed-length arrays in WIT
        fill_temp = re.sub(r'Array\[\s*(\d+),\s*(\S+)\s*\]', matchrep, fill_temp)
        
        self.write_file('wali.wit', fill_temp)


class MarkdownGenerator(StubGenerator):
    def generate(self):
        syscalls_lib = system_calls.syscalls()
        arch_remap = {'rv64': 'riscv64'}
        arch_supp_mapped = {arch_remap.get(x, x) for x in self.archs}
        
        arch_calls = [set(syscalls_lib.load_arch_table(v).keys()) for v in arch_supp_mapped]
        arch_call_set = set().union(*arch_calls)

        # Build list of dicts for pandas-free table generation or just bare formatting
        # Note: raw_syscalls is now List[Syscall] objects
        
        # Supported set: where args are present (implemented)
        supp_sc = [s for s in self.syscalls.values() if s.implemented]
        supp_set = set(s.name for s in supp_sc)
        
        # Generate markdown table
        # Columns: Syscall, # Args, a1..a6
        header = "| Syscall | # Args | a1 | a2 | a3 | a4 | a5 | a6 |"
        sep = "| --- | --- | --- | --- | --- | --- | --- | --- |"
        rows = []
        for s in supp_sc:
            args = s.args
            nargs = len(args)
            # Pad args to 6
            padded_args = args + [''] * (6 - nargs)
            # Escape strings
            def esc(x): return str(x).replace('*', r'\*').replace('_', r'\_')
            
            row_vals = [esc(s.name), str(nargs)] + [esc(a) for a in padded_args]
            rows.append("| " + " | ".join(row_vals) + " |")
        
        md_table = "\n".join([header, sep] + rows)

        unsupp_set = arch_call_set.difference(supp_set)
        unsupp_list = [f"* {x}" for x in sorted(unsupp_set)]

        try:
            with open('templates/support.md.template', 'r') as f:
                template = f.read()
        except FileNotFoundError:
            template = ""

        fill_temp = template.replace(
            '[[NUM_SUPPORTED_SYSCALLS_STUB]]', 
            str(len(supp_sc))
        ).replace(
            '[[SUPPORTED_SYSCALLS_STUB]]', 
            md_table
        ).replace(
            '[[UNSUPPORTED_SYSCALLS_STUB]]', 
            '\n'.join(unsupp_list).replace('_', r'\_')
        )

        self.write_file('support.md', fill_temp)


# --- Registry & Main ---

GENERATORS = {
    'libc': LibcGenerator,
    'wamr': WamrGenerator,
    'wit': WitGenerator,
    'markdown': MarkdownGenerator
}

def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        prog='wali-autogen', 
        description="Generate WALI descriptions/implementations/stubs"
    )
    parser.add_argument('--verbose', '-v', 
                        help='Logging verbosity', 
                        choices=range(6), type=int, default=4)
    parser.add_argument('stubs', 
                        nargs='*', 
                        choices=list(GENERATORS.keys())+['all'], 
                        default='all')
    p = parser.parse_args()
    
    if p.stubs == 'all' or (isinstance(p.stubs, list) and 'all' in p.stubs):
        p.stubs = list(GENERATORS.keys())
    # Ensure list
    if isinstance(p.stubs, str):
        p.stubs = [p.stubs]
        
    return p

def main():
    args = parse_args()
    log_level = logging.getLevelName((6-args.verbose)*10) if args.verbose != 0 else logging.NOTSET
    logging.basicConfig(level=log_level, format='%(levelname)s: %(message)s')

    # Initialize shared context
    ctx = GeneratorContext.create()

    for stub_name in args.stubs:
        if stub_name not in GENERATORS:
            logging.warning(f"Unknown stub type: {stub_name}")
            continue
            
        logging.info(f"Generating {stub_name} stubs")
        spath = Path('autogen') / stub_name
        
        # Instantiate and run generator
        GeneratorClass = GENERATORS[stub_name]
        try:
            gen = GeneratorClass(spath, ctx)
            gen.generate()
        except Exception as e:
            logging.error(f"Failed to generate {stub_name}: {e}", exc_info=True)

if __name__ == '__main__':
    main()
